// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: pb.proto

package pb

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type Gender int32

const (
	Gender_men   Gender = 0
	Gender_women Gender = 1
)

var Gender_name = map[int32]string{
	0: "men",
	1: "women",
}

var Gender_value = map[string]int32{
	"men":   0,
	"women": 1,
}

func (x Gender) String() string {
	return proto.EnumName(Gender_name, int32(x))
}

func (Gender) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{0}
}

type AccountType int32

const (
	AccountType_Margin AccountType = 0
	AccountType_Cash   AccountType = 1
)

var AccountType_name = map[int32]string{
	0: "Margin",
	1: "Cash",
}

var AccountType_value = map[string]int32{
	"Margin": 0,
	"Cash":   1,
}

func (x AccountType) String() string {
	return proto.EnumName(AccountType_name, int32(x))
}

func (AccountType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{1}
}

type AccountLevel int32

const (
	AccountLevel_Main AccountLevel = 0
	AccountLevel_Sub  AccountLevel = 1
)

var AccountLevel_name = map[int32]string{
	0: "Main",
	1: "Sub",
}

var AccountLevel_value = map[string]int32{
	"Main": 0,
	"Sub":  1,
}

func (x AccountLevel) String() string {
	return proto.EnumName(AccountLevel_name, int32(x))
}

func (AccountLevel) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{2}
}

type AccountClass int32

const (
	AccountClass_Personal      AccountClass = 0
	AccountClass_Institutional AccountClass = 1
)

var AccountClass_name = map[int32]string{
	0: "Personal",
	1: "Institutional",
}

var AccountClass_value = map[string]int32{
	"Personal":      0,
	"Institutional": 1,
}

func (x AccountClass) String() string {
	return proto.EnumName(AccountClass_name, int32(x))
}

func (AccountClass) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{3}
}

type Person struct {
	Id                   uint64   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Name                 string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty" idx:"normal"`
	Phone                string   `protobuf:"bytes,3,opt,name=phone,proto3" json:"phone,omitempty" idx:"unique"`
	Age                  uint32   `protobuf:"varint,4,opt,name=age,proto3" json:"age,omitempty" idx:"normal"`
	BirthDay             uint32   `protobuf:"varint,5,opt,name=birthDay,proto3" json:"birthDay,omitempty"`
	Gender               Gender   `protobuf:"varint,6,opt,name=gender,proto3,enum=pb.Gender" json:"gender,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Person) Reset()         { *m = Person{} }
func (m *Person) String() string { return proto.CompactTextString(m) }
func (*Person) ProtoMessage()    {}
func (*Person) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{0}
}
func (m *Person) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Person) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Person.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Person) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Person.Merge(m, src)
}
func (m *Person) XXX_Size() int {
	return m.Size()
}
func (m *Person) XXX_DiscardUnknown() {
	xxx_messageInfo_Person.DiscardUnknown(m)
}

var xxx_messageInfo_Person proto.InternalMessageInfo

func (m *Person) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Person) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Person) GetPhone() string {
	if m != nil {
		return m.Phone
	}
	return ""
}

func (m *Person) GetAge() uint32 {
	if m != nil {
		return m.Age
	}
	return 0
}

func (m *Person) GetBirthDay() uint32 {
	if m != nil {
		return m.BirthDay
	}
	return 0
}

func (m *Person) GetGender() Gender {
	if m != nil {
		return m.Gender
	}
	return Gender_men
}

type Order struct {
	Id                   uint64   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	AccountChannel       string   `protobuf:"bytes,2,opt,name=account_channel,json=accountChannel,proto3" json:"account_channel,omitempty" idx:"union"`
	Aaid                 uint64   `protobuf:"varint,3,opt,name=aaid,proto3" json:"aaid,omitempty" idx:"union"`
	OrderId              string   `protobuf:"bytes,4,opt,name=order_id,json=orderId,proto3" json:"order_id,omitempty" idx:"union"`
	OrgId                string   `protobuf:"bytes,5,opt,name=org_id,json=orgId,proto3" json:"org_id,omitempty" idx:"normal"`
	CounterId            string   `protobuf:"bytes,6,opt,name=counter_id,json=counterId,proto3" json:"counter_id,omitempty" idx:"normal"`
	Currency             string   `protobuf:"bytes,7,opt,name=currency,proto3" json:"currency,omitempty" idx:"normal"`
	Market               string   `protobuf:"bytes,8,opt,name=market,proto3" json:"market,omitempty"`
	EntrustType          int32    `protobuf:"varint,9,opt,name=entrust_type,json=entrustType,proto3" json:"entrust_type,omitempty"`
	EntrustStatus        int32    `protobuf:"varint,10,opt,name=entrust_status,json=entrustStatus,proto3" json:"entrust_status,omitempty"`
	Side                 int32    `protobuf:"varint,11,opt,name=side,proto3" json:"side,omitempty"`
	EntrustAmount        string   `protobuf:"bytes,12,opt,name=entrust_amount,json=entrustAmount,proto3" json:"entrust_amount,omitempty"`
	EntrustQty           string   `protobuf:"bytes,13,opt,name=entrust_qty,json=entrustQty,proto3" json:"entrust_qty,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Order) Reset()         { *m = Order{} }
func (m *Order) String() string { return proto.CompactTextString(m) }
func (*Order) ProtoMessage()    {}
func (*Order) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{1}
}
func (m *Order) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Order) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Order.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Order) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Order.Merge(m, src)
}
func (m *Order) XXX_Size() int {
	return m.Size()
}
func (m *Order) XXX_DiscardUnknown() {
	xxx_messageInfo_Order.DiscardUnknown(m)
}

var xxx_messageInfo_Order proto.InternalMessageInfo

func (m *Order) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Order) GetAccountChannel() string {
	if m != nil {
		return m.AccountChannel
	}
	return ""
}

func (m *Order) GetAaid() uint64 {
	if m != nil {
		return m.Aaid
	}
	return 0
}

func (m *Order) GetOrderId() string {
	if m != nil {
		return m.OrderId
	}
	return ""
}

func (m *Order) GetOrgId() string {
	if m != nil {
		return m.OrgId
	}
	return ""
}

func (m *Order) GetCounterId() string {
	if m != nil {
		return m.CounterId
	}
	return ""
}

func (m *Order) GetCurrency() string {
	if m != nil {
		return m.Currency
	}
	return ""
}

func (m *Order) GetMarket() string {
	if m != nil {
		return m.Market
	}
	return ""
}

func (m *Order) GetEntrustType() int32 {
	if m != nil {
		return m.EntrustType
	}
	return 0
}

func (m *Order) GetEntrustStatus() int32 {
	if m != nil {
		return m.EntrustStatus
	}
	return 0
}

func (m *Order) GetSide() int32 {
	if m != nil {
		return m.Side
	}
	return 0
}

func (m *Order) GetEntrustAmount() string {
	if m != nil {
		return m.EntrustAmount
	}
	return ""
}

func (m *Order) GetEntrustQty() string {
	if m != nil {
		return m.EntrustQty
	}
	return ""
}

type IllegalPerson_1 struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty" idx:"normal"`
	Phone                string   `protobuf:"bytes,2,opt,name=phone,proto3" json:"phone,omitempty" idx:"unique"`
	Age                  uint32   `protobuf:"varint,3,opt,name=age,proto3" json:"age,omitempty" idx:"normal"`
	BirthDay             uint32   `protobuf:"varint,4,opt,name=birthDay,proto3" json:"birthDay,omitempty"`
	Gender               Gender   `protobuf:"varint,5,opt,name=gender,proto3,enum=pb.Gender" json:"gender,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IllegalPerson_1) Reset()         { *m = IllegalPerson_1{} }
func (m *IllegalPerson_1) String() string { return proto.CompactTextString(m) }
func (*IllegalPerson_1) ProtoMessage()    {}
func (*IllegalPerson_1) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{2}
}
func (m *IllegalPerson_1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IllegalPerson_1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IllegalPerson_1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IllegalPerson_1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IllegalPerson_1.Merge(m, src)
}
func (m *IllegalPerson_1) XXX_Size() int {
	return m.Size()
}
func (m *IllegalPerson_1) XXX_DiscardUnknown() {
	xxx_messageInfo_IllegalPerson_1.DiscardUnknown(m)
}

var xxx_messageInfo_IllegalPerson_1 proto.InternalMessageInfo

func (m *IllegalPerson_1) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *IllegalPerson_1) GetPhone() string {
	if m != nil {
		return m.Phone
	}
	return ""
}

func (m *IllegalPerson_1) GetAge() uint32 {
	if m != nil {
		return m.Age
	}
	return 0
}

func (m *IllegalPerson_1) GetBirthDay() uint32 {
	if m != nil {
		return m.BirthDay
	}
	return 0
}

func (m *IllegalPerson_1) GetGender() Gender {
	if m != nil {
		return m.Gender
	}
	return Gender_men
}

type IllegalPerson_2 struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Name                 string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty" idx:"normal"`
	Phone                string   `protobuf:"bytes,3,opt,name=phone,proto3" json:"phone,omitempty" idx:"unique"`
	Age                  uint32   `protobuf:"varint,4,opt,name=age,proto3" json:"age,omitempty" idx:"normal"`
	BirthDay             uint32   `protobuf:"varint,5,opt,name=birthDay,proto3" json:"birthDay,omitempty"`
	Gender               Gender   `protobuf:"varint,6,opt,name=gender,proto3,enum=pb.Gender" json:"gender,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IllegalPerson_2) Reset()         { *m = IllegalPerson_2{} }
func (m *IllegalPerson_2) String() string { return proto.CompactTextString(m) }
func (*IllegalPerson_2) ProtoMessage()    {}
func (*IllegalPerson_2) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{3}
}
func (m *IllegalPerson_2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IllegalPerson_2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IllegalPerson_2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IllegalPerson_2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IllegalPerson_2.Merge(m, src)
}
func (m *IllegalPerson_2) XXX_Size() int {
	return m.Size()
}
func (m *IllegalPerson_2) XXX_DiscardUnknown() {
	xxx_messageInfo_IllegalPerson_2.DiscardUnknown(m)
}

var xxx_messageInfo_IllegalPerson_2 proto.InternalMessageInfo

func (m *IllegalPerson_2) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *IllegalPerson_2) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *IllegalPerson_2) GetPhone() string {
	if m != nil {
		return m.Phone
	}
	return ""
}

func (m *IllegalPerson_2) GetAge() uint32 {
	if m != nil {
		return m.Age
	}
	return 0
}

func (m *IllegalPerson_2) GetBirthDay() uint32 {
	if m != nil {
		return m.BirthDay
	}
	return 0
}

func (m *IllegalPerson_2) GetGender() Gender {
	if m != nil {
		return m.Gender
	}
	return Gender_men
}

type Detail struct {
	OutStanding          string   `protobuf:"bytes,1,opt,name=out_standing,json=outStanding,proto3" json:"out_standing,omitempty"`
	UnitOnHand           string   `protobuf:"bytes,2,opt,name=unit_on_hand,json=unitOnHand,proto3" json:"unit_on_hand,omitempty"`
	OutStandingFrozen    string   `protobuf:"bytes,3,opt,name=out_standing_frozen,json=outStandingFrozen,proto3" json:"out_standing_frozen,omitempty"`
	UnitOnHandFrozen     string   `protobuf:"bytes,4,opt,name=unit_on_hand_frozen,json=unitOnHandFrozen,proto3" json:"unit_on_hand_frozen,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Detail) Reset()         { *m = Detail{} }
func (m *Detail) String() string { return proto.CompactTextString(m) }
func (*Detail) ProtoMessage()    {}
func (*Detail) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{4}
}
func (m *Detail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Detail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Detail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Detail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Detail.Merge(m, src)
}
func (m *Detail) XXX_Size() int {
	return m.Size()
}
func (m *Detail) XXX_DiscardUnknown() {
	xxx_messageInfo_Detail.DiscardUnknown(m)
}

var xxx_messageInfo_Detail proto.InternalMessageInfo

func (m *Detail) GetOutStanding() string {
	if m != nil {
		return m.OutStanding
	}
	return ""
}

func (m *Detail) GetUnitOnHand() string {
	if m != nil {
		return m.UnitOnHand
	}
	return ""
}

func (m *Detail) GetOutStandingFrozen() string {
	if m != nil {
		return m.OutStandingFrozen
	}
	return ""
}

func (m *Detail) GetUnitOnHandFrozen() string {
	if m != nil {
		return m.UnitOnHandFrozen
	}
	return ""
}

type AccountInfo struct {
	Id                   uint64             `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	AccountChannel       string             `protobuf:"bytes,2,opt,name=account_channel,json=accountChannel,proto3" json:"account_channel,omitempty" idx:"union"`
	Aaid                 uint64             `protobuf:"varint,3,opt,name=aaid,proto3" json:"aaid,omitempty" idx:"union"`
	CashBooks            map[string]*Detail `protobuf:"bytes,4,rep,name=cash_books,json=cashBooks,proto3" json:"cash_books,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	StockBooks           map[string]*Detail `protobuf:"bytes,5,rep,name=stock_books,json=stockBooks,proto3" json:"stock_books,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	AccountProperties    *AccountProperties `protobuf:"bytes,6,opt,name=account_properties,json=accountProperties,proto3" json:"account_properties,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *AccountInfo) Reset()         { *m = AccountInfo{} }
func (m *AccountInfo) String() string { return proto.CompactTextString(m) }
func (*AccountInfo) ProtoMessage()    {}
func (*AccountInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{5}
}
func (m *AccountInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccountInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccountInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AccountInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccountInfo.Merge(m, src)
}
func (m *AccountInfo) XXX_Size() int {
	return m.Size()
}
func (m *AccountInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_AccountInfo.DiscardUnknown(m)
}

var xxx_messageInfo_AccountInfo proto.InternalMessageInfo

func (m *AccountInfo) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *AccountInfo) GetAccountChannel() string {
	if m != nil {
		return m.AccountChannel
	}
	return ""
}

func (m *AccountInfo) GetAaid() uint64 {
	if m != nil {
		return m.Aaid
	}
	return 0
}

func (m *AccountInfo) GetCashBooks() map[string]*Detail {
	if m != nil {
		return m.CashBooks
	}
	return nil
}

func (m *AccountInfo) GetStockBooks() map[string]*Detail {
	if m != nil {
		return m.StockBooks
	}
	return nil
}

func (m *AccountInfo) GetAccountProperties() *AccountProperties {
	if m != nil {
		return m.AccountProperties
	}
	return nil
}

type AccountProperties struct {
	MaxFinance           string       `protobuf:"bytes,1,opt,name=max_finance,json=maxFinance,proto3" json:"max_finance,omitempty"`
	MainCurrency         string       `protobuf:"bytes,2,opt,name=main_currency,json=mainCurrency,proto3" json:"main_currency,omitempty"`
	MaxTradeCredit       string       `protobuf:"bytes,3,opt,name=max_trade_credit,json=maxTradeCredit,proto3" json:"max_trade_credit,omitempty"`
	AccountType          AccountType  `protobuf:"varint,4,opt,name=account_type,json=accountType,proto3,enum=pb.AccountType" json:"account_type,omitempty"`
	AccountLevel         AccountLevel `protobuf:"varint,5,opt,name=account_level,json=accountLevel,proto3,enum=pb.AccountLevel" json:"account_level,omitempty"`
	AccountClass         AccountClass `protobuf:"varint,6,opt,name=account_class,json=accountClass,proto3,enum=pb.AccountClass" json:"account_class,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *AccountProperties) Reset()         { *m = AccountProperties{} }
func (m *AccountProperties) String() string { return proto.CompactTextString(m) }
func (*AccountProperties) ProtoMessage()    {}
func (*AccountProperties) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{6}
}
func (m *AccountProperties) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccountProperties) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccountProperties.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AccountProperties) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccountProperties.Merge(m, src)
}
func (m *AccountProperties) XXX_Size() int {
	return m.Size()
}
func (m *AccountProperties) XXX_DiscardUnknown() {
	xxx_messageInfo_AccountProperties.DiscardUnknown(m)
}

var xxx_messageInfo_AccountProperties proto.InternalMessageInfo

func (m *AccountProperties) GetMaxFinance() string {
	if m != nil {
		return m.MaxFinance
	}
	return ""
}

func (m *AccountProperties) GetMainCurrency() string {
	if m != nil {
		return m.MainCurrency
	}
	return ""
}

func (m *AccountProperties) GetMaxTradeCredit() string {
	if m != nil {
		return m.MaxTradeCredit
	}
	return ""
}

func (m *AccountProperties) GetAccountType() AccountType {
	if m != nil {
		return m.AccountType
	}
	return AccountType_Margin
}

func (m *AccountProperties) GetAccountLevel() AccountLevel {
	if m != nil {
		return m.AccountLevel
	}
	return AccountLevel_Main
}

func (m *AccountProperties) GetAccountClass() AccountClass {
	if m != nil {
		return m.AccountClass
	}
	return AccountClass_Personal
}

type Account struct {
	Id                   uint64   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	AccountNo            string   `protobuf:"bytes,2,opt,name=account_no,json=accountNo,proto3" json:"account_no,omitempty" idx:"union"`
	PhoneNumber          string   `protobuf:"bytes,3,opt,name=phone_number,json=phoneNumber,proto3" json:"phone_number,omitempty" idx:"union"`
	Identification       string   `protobuf:"bytes,4,opt,name=identification,proto3" json:"identification,omitempty" idx:"unique"`
	Gender               uint32   `protobuf:"varint,5,opt,name=gender,proto3" json:"gender,omitempty" idx:"normal"`
	Age                  uint32   `protobuf:"varint,6,opt,name=age,proto3" json:"age,omitempty" idx:"normal"`
	Address              string   `protobuf:"bytes,7,opt,name=address,proto3" json:"address,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Account) Reset()         { *m = Account{} }
func (m *Account) String() string { return proto.CompactTextString(m) }
func (*Account) ProtoMessage()    {}
func (*Account) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{7}
}
func (m *Account) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Account) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Account.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Account) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Account.Merge(m, src)
}
func (m *Account) XXX_Size() int {
	return m.Size()
}
func (m *Account) XXX_DiscardUnknown() {
	xxx_messageInfo_Account.DiscardUnknown(m)
}

var xxx_messageInfo_Account proto.InternalMessageInfo

func (m *Account) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Account) GetAccountNo() string {
	if m != nil {
		return m.AccountNo
	}
	return ""
}

func (m *Account) GetPhoneNumber() string {
	if m != nil {
		return m.PhoneNumber
	}
	return ""
}

func (m *Account) GetIdentification() string {
	if m != nil {
		return m.Identification
	}
	return ""
}

func (m *Account) GetGender() uint32 {
	if m != nil {
		return m.Gender
	}
	return 0
}

func (m *Account) GetAge() uint32 {
	if m != nil {
		return m.Age
	}
	return 0
}

func (m *Account) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

type OrderPot struct {
	Id                   uint64   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	AccountChannel       string   `protobuf:"bytes,2,opt,name=account_channel,json=accountChannel,proto3" json:"account_channel,omitempty" idx:"union"`
	Aaid                 uint64   `protobuf:"varint,3,opt,name=aaid,proto3" json:"aaid,omitempty" idx:"union"`
	OrderId              int64    `protobuf:"varint,4,opt,name=order_id,json=orderId,proto3" json:"order_id,omitempty" idx:"union"`
	OrgId                int64    `protobuf:"varint,5,opt,name=org_id,json=orgId,proto3" json:"org_id,omitempty" idx:"normal"`
	CounterId            string   `protobuf:"bytes,6,opt,name=counter_id,json=counterId,proto3" json:"counter_id,omitempty" idx:"normal"`
	Currency             string   `protobuf:"bytes,7,opt,name=currency,proto3" json:"currency,omitempty" idx:"normal"`
	Market               string   `protobuf:"bytes,8,opt,name=market,proto3" json:"market,omitempty" idx:"normal"`
	EntrustType          int32    `protobuf:"varint,9,opt,name=entrust_type,json=entrustType,proto3" json:"entrust_type,omitempty" idx:"normal"`
	EntrustStatus        int32    `protobuf:"varint,10,opt,name=entrust_status,json=entrustStatus,proto3" json:"entrust_status,omitempty" idx:"normal"`
	Side                 int32    `protobuf:"varint,11,opt,name=side,proto3" json:"side,omitempty"`
	EntrustAmount        string   `protobuf:"bytes,12,opt,name=entrust_amount,json=entrustAmount,proto3" json:"entrust_amount,omitempty"`
	EntrustQty           string   `protobuf:"bytes,13,opt,name=entrust_qty,json=entrustQty,proto3" json:"entrust_qty,omitempty"`
	Liveness             int32    `protobuf:"varint,14,opt,name=liveness,proto3" json:"liveness,omitempty" idx:"normal"`
	IsAttached           int32    `protobuf:"varint,15,opt,name=is_attached,json=isAttached,proto3" json:"is_attached,omitempty" idx:"normal"`
	X3                   int32    `protobuf:"varint,16,opt,name=x3,proto3" json:"x3,omitempty"`
	X4                   int32    `protobuf:"varint,17,opt,name=x4,proto3" json:"x4,omitempty"`
	X5                   int32    `protobuf:"varint,18,opt,name=x5,proto3" json:"x5,omitempty"`
	X11                  string   `protobuf:"bytes,19,opt,name=x11,proto3" json:"x11,omitempty"`
	X12                  string   `protobuf:"bytes,20,opt,name=x12,proto3" json:"x12,omitempty"`
	X13                  string   `protobuf:"bytes,21,opt,name=x13,proto3" json:"x13,omitempty"`
	X14                  string   `protobuf:"bytes,22,opt,name=x14,proto3" json:"x14,omitempty"`
	X15                  string   `protobuf:"bytes,23,opt,name=x15,proto3" json:"x15,omitempty"`
	X16                  int32    `protobuf:"varint,24,opt,name=x16,proto3" json:"x16,omitempty"`
	X17                  int32    `protobuf:"varint,25,opt,name=x17,proto3" json:"x17,omitempty"`
	X18                  int32    `protobuf:"varint,26,opt,name=x18,proto3" json:"x18,omitempty"`
	X19                  int32    `protobuf:"varint,27,opt,name=x19,proto3" json:"x19,omitempty"`
	X20                  int32    `protobuf:"varint,28,opt,name=x20,proto3" json:"x20,omitempty"`
	X21                  string   `protobuf:"bytes,29,opt,name=x21,proto3" json:"x21,omitempty"`
	X22                  string   `protobuf:"bytes,30,opt,name=x22,proto3" json:"x22,omitempty"`
	X23                  string   `protobuf:"bytes,31,opt,name=x23,proto3" json:"x23,omitempty"`
	X24                  string   `protobuf:"bytes,32,opt,name=x24,proto3" json:"x24,omitempty"`
	X25                  string   `protobuf:"bytes,33,opt,name=x25,proto3" json:"x25,omitempty"`
	X26                  int32    `protobuf:"varint,34,opt,name=x26,proto3" json:"x26,omitempty"`
	X27                  int32    `protobuf:"varint,35,opt,name=x27,proto3" json:"x27,omitempty"`
	X28                  int32    `protobuf:"varint,36,opt,name=x28,proto3" json:"x28,omitempty"`
	X29                  int32    `protobuf:"varint,37,opt,name=x29,proto3" json:"x29,omitempty"`
	X30                  int32    `protobuf:"varint,38,opt,name=x30,proto3" json:"x30,omitempty"`
	X31                  string   `protobuf:"bytes,39,opt,name=x31,proto3" json:"x31,omitempty"`
	X32                  string   `protobuf:"bytes,40,opt,name=x32,proto3" json:"x32,omitempty"`
	X33                  string   `protobuf:"bytes,41,opt,name=x33,proto3" json:"x33,omitempty"`
	X34                  string   `protobuf:"bytes,42,opt,name=x34,proto3" json:"x34,omitempty"`
	X35                  string   `protobuf:"bytes,43,opt,name=x35,proto3" json:"x35,omitempty"`
	X36                  int32    `protobuf:"varint,44,opt,name=x36,proto3" json:"x36,omitempty"`
	X37                  int32    `protobuf:"varint,45,opt,name=x37,proto3" json:"x37,omitempty"`
	X38                  int32    `protobuf:"varint,46,opt,name=x38,proto3" json:"x38,omitempty"`
	X39                  string   `protobuf:"bytes,47,opt,name=x39,proto3" json:"x39,omitempty"`
	X40                  string   `protobuf:"bytes,48,opt,name=x40,proto3" json:"x40,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OrderPot) Reset()         { *m = OrderPot{} }
func (m *OrderPot) String() string { return proto.CompactTextString(m) }
func (*OrderPot) ProtoMessage()    {}
func (*OrderPot) Descriptor() ([]byte, []int) {
	return fileDescriptor_f80abaa17e25ccc8, []int{8}
}
func (m *OrderPot) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OrderPot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OrderPot.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OrderPot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrderPot.Merge(m, src)
}
func (m *OrderPot) XXX_Size() int {
	return m.Size()
}
func (m *OrderPot) XXX_DiscardUnknown() {
	xxx_messageInfo_OrderPot.DiscardUnknown(m)
}

var xxx_messageInfo_OrderPot proto.InternalMessageInfo

func (m *OrderPot) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *OrderPot) GetAccountChannel() string {
	if m != nil {
		return m.AccountChannel
	}
	return ""
}

func (m *OrderPot) GetAaid() uint64 {
	if m != nil {
		return m.Aaid
	}
	return 0
}

func (m *OrderPot) GetOrderId() int64 {
	if m != nil {
		return m.OrderId
	}
	return 0
}

func (m *OrderPot) GetOrgId() int64 {
	if m != nil {
		return m.OrgId
	}
	return 0
}

func (m *OrderPot) GetCounterId() string {
	if m != nil {
		return m.CounterId
	}
	return ""
}

func (m *OrderPot) GetCurrency() string {
	if m != nil {
		return m.Currency
	}
	return ""
}

func (m *OrderPot) GetMarket() string {
	if m != nil {
		return m.Market
	}
	return ""
}

func (m *OrderPot) GetEntrustType() int32 {
	if m != nil {
		return m.EntrustType
	}
	return 0
}

func (m *OrderPot) GetEntrustStatus() int32 {
	if m != nil {
		return m.EntrustStatus
	}
	return 0
}

func (m *OrderPot) GetSide() int32 {
	if m != nil {
		return m.Side
	}
	return 0
}

func (m *OrderPot) GetEntrustAmount() string {
	if m != nil {
		return m.EntrustAmount
	}
	return ""
}

func (m *OrderPot) GetEntrustQty() string {
	if m != nil {
		return m.EntrustQty
	}
	return ""
}

func (m *OrderPot) GetLiveness() int32 {
	if m != nil {
		return m.Liveness
	}
	return 0
}

func (m *OrderPot) GetIsAttached() int32 {
	if m != nil {
		return m.IsAttached
	}
	return 0
}

func (m *OrderPot) GetX3() int32 {
	if m != nil {
		return m.X3
	}
	return 0
}

func (m *OrderPot) GetX4() int32 {
	if m != nil {
		return m.X4
	}
	return 0
}

func (m *OrderPot) GetX5() int32 {
	if m != nil {
		return m.X5
	}
	return 0
}

func (m *OrderPot) GetX11() string {
	if m != nil {
		return m.X11
	}
	return ""
}

func (m *OrderPot) GetX12() string {
	if m != nil {
		return m.X12
	}
	return ""
}

func (m *OrderPot) GetX13() string {
	if m != nil {
		return m.X13
	}
	return ""
}

func (m *OrderPot) GetX14() string {
	if m != nil {
		return m.X14
	}
	return ""
}

func (m *OrderPot) GetX15() string {
	if m != nil {
		return m.X15
	}
	return ""
}

func (m *OrderPot) GetX16() int32 {
	if m != nil {
		return m.X16
	}
	return 0
}

func (m *OrderPot) GetX17() int32 {
	if m != nil {
		return m.X17
	}
	return 0
}

func (m *OrderPot) GetX18() int32 {
	if m != nil {
		return m.X18
	}
	return 0
}

func (m *OrderPot) GetX19() int32 {
	if m != nil {
		return m.X19
	}
	return 0
}

func (m *OrderPot) GetX20() int32 {
	if m != nil {
		return m.X20
	}
	return 0
}

func (m *OrderPot) GetX21() string {
	if m != nil {
		return m.X21
	}
	return ""
}

func (m *OrderPot) GetX22() string {
	if m != nil {
		return m.X22
	}
	return ""
}

func (m *OrderPot) GetX23() string {
	if m != nil {
		return m.X23
	}
	return ""
}

func (m *OrderPot) GetX24() string {
	if m != nil {
		return m.X24
	}
	return ""
}

func (m *OrderPot) GetX25() string {
	if m != nil {
		return m.X25
	}
	return ""
}

func (m *OrderPot) GetX26() int32 {
	if m != nil {
		return m.X26
	}
	return 0
}

func (m *OrderPot) GetX27() int32 {
	if m != nil {
		return m.X27
	}
	return 0
}

func (m *OrderPot) GetX28() int32 {
	if m != nil {
		return m.X28
	}
	return 0
}

func (m *OrderPot) GetX29() int32 {
	if m != nil {
		return m.X29
	}
	return 0
}

func (m *OrderPot) GetX30() int32 {
	if m != nil {
		return m.X30
	}
	return 0
}

func (m *OrderPot) GetX31() string {
	if m != nil {
		return m.X31
	}
	return ""
}

func (m *OrderPot) GetX32() string {
	if m != nil {
		return m.X32
	}
	return ""
}

func (m *OrderPot) GetX33() string {
	if m != nil {
		return m.X33
	}
	return ""
}

func (m *OrderPot) GetX34() string {
	if m != nil {
		return m.X34
	}
	return ""
}

func (m *OrderPot) GetX35() string {
	if m != nil {
		return m.X35
	}
	return ""
}

func (m *OrderPot) GetX36() int32 {
	if m != nil {
		return m.X36
	}
	return 0
}

func (m *OrderPot) GetX37() int32 {
	if m != nil {
		return m.X37
	}
	return 0
}

func (m *OrderPot) GetX38() int32 {
	if m != nil {
		return m.X38
	}
	return 0
}

func (m *OrderPot) GetX39() string {
	if m != nil {
		return m.X39
	}
	return ""
}

func (m *OrderPot) GetX40() string {
	if m != nil {
		return m.X40
	}
	return ""
}

func init() {
	proto.RegisterEnum("pb.Gender", Gender_name, Gender_value)
	proto.RegisterEnum("pb.AccountType", AccountType_name, AccountType_value)
	proto.RegisterEnum("pb.AccountLevel", AccountLevel_name, AccountLevel_value)
	proto.RegisterEnum("pb.AccountClass", AccountClass_name, AccountClass_value)
	proto.RegisterType((*Person)(nil), "pb.Person")
	proto.RegisterType((*Order)(nil), "pb.Order")
	proto.RegisterType((*IllegalPerson_1)(nil), "pb.IllegalPerson_1")
	proto.RegisterType((*IllegalPerson_2)(nil), "pb.IllegalPerson_2")
	proto.RegisterType((*Detail)(nil), "pb.Detail")
	proto.RegisterType((*AccountInfo)(nil), "pb.AccountInfo")
	proto.RegisterMapType((map[string]*Detail)(nil), "pb.AccountInfo.CashBooksEntry")
	proto.RegisterMapType((map[string]*Detail)(nil), "pb.AccountInfo.StockBooksEntry")
	proto.RegisterType((*AccountProperties)(nil), "pb.AccountProperties")
	proto.RegisterType((*Account)(nil), "pb.Account")
	proto.RegisterType((*OrderPot)(nil), "pb.OrderPot")
}

func init() { proto.RegisterFile("pb.proto", fileDescriptor_f80abaa17e25ccc8) }

var fileDescriptor_f80abaa17e25ccc8 = []byte{
	// 1368 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x57, 0x4b, 0x6f, 0xdb, 0xd6,
	0x12, 0x0e, 0xf5, 0xb2, 0x34, 0x92, 0x65, 0xf9, 0xe4, 0x26, 0xf7, 0x5c, 0xdf, 0x5c, 0x5b, 0xa1,
	0xf3, 0xd0, 0x75, 0x13, 0xd9, 0x22, 0xe5, 0xd8, 0x0e, 0x50, 0xa0, 0x89, 0xd3, 0x34, 0x02, 0x9a,
	0x47, 0x99, 0xec, 0x89, 0x23, 0xf2, 0x58, 0x22, 0x2c, 0x1d, 0x2a, 0x7c, 0xa4, 0x52, 0x7f, 0x49,
	0x77, 0x5d, 0x75, 0xd7, 0x7f, 0xd1, 0x4d, 0xd1, 0x45, 0x51, 0xa0, 0x9b, 0xae, 0x82, 0x22, 0xdd,
	0x74, 0x9d, 0x5f, 0x50, 0x9c, 0x97, 0x22, 0xdb, 0x52, 0x61, 0x74, 0x91, 0xa0, 0x3b, 0xce, 0x37,
	0xdf, 0xcc, 0xf9, 0x86, 0x9a, 0x33, 0x1c, 0x41, 0x71, 0xd4, 0x6d, 0x8e, 0xa2, 0x30, 0x09, 0x51,
	0x66, 0xd4, 0x5d, 0xbb, 0xdd, 0x0b, 0x92, 0x7e, 0xda, 0x6d, 0x7a, 0xe1, 0x70, 0xbb, 0x17, 0xf6,
	0xc2, 0x6d, 0xe1, 0xea, 0xa6, 0x47, 0xc2, 0x12, 0x86, 0x78, 0x92, 0x21, 0xe6, 0x8f, 0x06, 0x14,
	0x9e, 0xd1, 0x28, 0x0e, 0x19, 0xaa, 0x42, 0x26, 0xf0, 0xb1, 0x51, 0x37, 0x1a, 0x39, 0x27, 0x13,
	0xf8, 0xe8, 0x1a, 0xe4, 0x18, 0x19, 0x52, 0x9c, 0xa9, 0x1b, 0x8d, 0xd2, 0xfd, 0xda, 0xdb, 0xd7,
	0x1b, 0x95, 0xc0, 0x1f, 0xdf, 0x35, 0x59, 0x18, 0x0d, 0xc9, 0xc0, 0x74, 0x84, 0x17, 0xdd, 0x80,
	0xfc, 0xa8, 0x1f, 0x32, 0x8a, 0xb3, 0xa7, 0x68, 0x29, 0x0b, 0x5e, 0xa6, 0xd4, 0x74, 0xa4, 0x1b,
	0x99, 0x90, 0x25, 0x3d, 0x8a, 0x73, 0x75, 0xa3, 0xb1, 0x3c, 0x27, 0x19, 0x77, 0xa2, 0x35, 0x28,
	0x76, 0x83, 0x28, 0xe9, 0x3f, 0x20, 0x13, 0x9c, 0xe7, 0x44, 0x67, 0x6a, 0x23, 0x13, 0x0a, 0x3d,
	0xca, 0x7c, 0x1a, 0xe1, 0x42, 0xdd, 0x68, 0x54, 0x2d, 0x68, 0x8e, 0xba, 0xcd, 0xcf, 0x04, 0xe2,
	0x28, 0x8f, 0xf9, 0x47, 0x16, 0xf2, 0x4f, 0x23, 0x9f, 0x46, 0x67, 0x6a, 0xd9, 0x87, 0x15, 0xe2,
	0x79, 0x61, 0xca, 0x12, 0xd7, 0xeb, 0x13, 0xc6, 0xe8, 0x40, 0x95, 0xb5, 0xf2, 0xf6, 0xf5, 0x46,
	0x59, 0xeb, 0x0d, 0x99, 0xe9, 0x54, 0x15, 0xef, 0x50, 0xd2, 0xd0, 0x26, 0xe4, 0x08, 0x09, 0x7c,
	0x51, 0x5e, 0xee, 0x2c, 0x5d, 0x38, 0xd1, 0x16, 0x14, 0x43, 0x7e, 0xae, 0x1b, 0xf8, 0xa2, 0xc2,
	0x39, 0x79, 0x97, 0x04, 0xa1, 0xe3, 0xa3, 0x9b, 0x50, 0x08, 0xa3, 0x1e, 0x67, 0xe6, 0x17, 0xbc,
	0xd8, 0x7c, 0x18, 0xf5, 0x3a, 0x3e, 0xda, 0x06, 0x10, 0x4a, 0x64, 0xda, 0xc2, 0x02, 0x72, 0x49,
	0x71, 0x3a, 0x3e, 0xba, 0x05, 0x45, 0x2f, 0x8d, 0x22, 0xca, 0xbc, 0x09, 0x5e, 0x5a, 0x40, 0x9f,
	0x32, 0xd0, 0x65, 0x28, 0x0c, 0x49, 0x74, 0x4c, 0x13, 0x5c, 0xe4, 0x5c, 0x47, 0x59, 0xe8, 0x2a,
	0x54, 0x28, 0x4b, 0xa2, 0x34, 0x4e, 0xdc, 0x64, 0x32, 0xa2, 0xb8, 0x54, 0x37, 0x1a, 0x79, 0xa7,
	0xac, 0xb0, 0x17, 0x93, 0x11, 0x45, 0xd7, 0xa1, 0xaa, 0x29, 0x71, 0x42, 0x92, 0x34, 0xc6, 0x20,
	0x48, 0xcb, 0x0a, 0x7d, 0x2e, 0x40, 0x84, 0x20, 0x17, 0x07, 0x3e, 0xc5, 0x65, 0xe1, 0x14, 0xcf,
	0xb3, 0xa1, 0x64, 0xc8, 0x95, 0xe3, 0x8a, 0x38, 0x5d, 0x87, 0xde, 0x13, 0x20, 0xda, 0x00, 0x7d,
	0xa0, 0xfb, 0x32, 0x99, 0xe0, 0x65, 0xc1, 0x01, 0x05, 0x7d, 0x91, 0x4c, 0xcc, 0xef, 0x0d, 0x58,
	0xe9, 0x0c, 0x06, 0xb4, 0x47, 0x06, 0xb2, 0x7d, 0xdd, 0xd6, 0xb4, 0x61, 0x8d, 0xf3, 0x35, 0x6c,
	0xe6, 0x5c, 0x0d, 0x9b, 0x3d, 0x6f, 0xc3, 0xe6, 0x16, 0x36, 0x6c, 0x7e, 0x61, 0xc3, 0xfe, 0x72,
	0xa6, 0x0a, 0x6b, 0xa6, 0x75, 0x4b, 0xff, 0xd0, 0x6b, 0xf8, 0x9d, 0x01, 0x85, 0x07, 0x34, 0x21,
	0xc1, 0x80, 0x37, 0x53, 0x98, 0x8a, 0x2e, 0x61, 0x7e, 0xc0, 0x7a, 0xaa, 0xac, 0x72, 0x98, 0xf2,
	0x1e, 0x11, 0x10, 0xaa, 0x43, 0x25, 0x65, 0x41, 0xe2, 0x86, 0xcc, 0xed, 0x13, 0xe6, 0xcb, 0x3a,
	0x1d, 0xe0, 0xd8, 0x53, 0xf6, 0x88, 0x30, 0x1f, 0x35, 0xe1, 0xe2, 0x6c, 0x12, 0xf7, 0x28, 0x0a,
	0xbf, 0xa2, 0x4c, 0x56, 0xea, 0xac, 0xce, 0xe4, 0x7a, 0x28, 0x1c, 0xe8, 0x36, 0x5c, 0x9c, 0xcd,
	0xa8, 0xf9, 0xe2, 0x62, 0x3a, 0xb5, 0x77, 0x89, 0x25, 0xdd, 0xfc, 0x35, 0x0b, 0xe5, 0x7b, 0xf2,
	0xd2, 0x77, 0xd8, 0x51, 0xf8, 0xbe, 0x67, 0xc7, 0xc7, 0x00, 0x1e, 0x89, 0xfb, 0x6e, 0x37, 0x0c,
	0x8f, 0x63, 0x9c, 0xab, 0x67, 0x1b, 0x65, 0x6b, 0x9d, 0xbf, 0xd5, 0x19, 0x4d, 0xcd, 0x43, 0x12,
	0xf7, 0xef, 0x73, 0xc2, 0xa7, 0x2c, 0x89, 0x26, 0x4e, 0xc9, 0xd3, 0x36, 0xfa, 0x04, 0xca, 0x71,
	0x12, 0x7a, 0xc7, 0x2a, 0x3e, 0x2f, 0xe2, 0x37, 0x4e, 0xc7, 0x3f, 0xe7, 0x94, 0x99, 0x04, 0x10,
	0x4f, 0x01, 0xf4, 0x00, 0x90, 0xae, 0x6f, 0x14, 0x85, 0x23, 0x1a, 0x25, 0x01, 0x8d, 0xc5, 0xcf,
	0x5b, 0xb6, 0x2e, 0xcd, 0x24, 0x7a, 0x36, 0x75, 0x3a, 0xab, 0xe4, 0x34, 0xb4, 0xf6, 0x08, 0xaa,
	0x27, 0x45, 0xa2, 0x1a, 0x64, 0x8f, 0xe9, 0x44, 0xfd, 0xe4, 0xfc, 0x11, 0xd5, 0x21, 0xff, 0x8a,
	0x0c, 0x52, 0xd9, 0xcb, 0x65, 0xd9, 0x3b, 0xb2, 0x51, 0x1c, 0xe9, 0xb8, 0x9b, 0xd9, 0x37, 0xd6,
	0x3a, 0xb0, 0x72, 0x4a, 0xee, 0xdf, 0x4d, 0x65, 0x7e, 0x9b, 0x81, 0xd5, 0x33, 0xea, 0xf9, 0x70,
	0x19, 0x92, 0xb1, 0x7b, 0x14, 0x30, 0xc2, 0x3c, 0x35, 0x2e, 0x1c, 0x18, 0x92, 0xf1, 0x43, 0x89,
	0xa0, 0x4d, 0x58, 0x1e, 0x92, 0x80, 0xb9, 0xd3, 0x69, 0x2a, 0x7b, 0xb2, 0xc2, 0xc1, 0x43, 0x3d,
	0x3f, 0x1b, 0x50, 0xe3, 0x59, 0x92, 0x88, 0xf8, 0xd4, 0xf5, 0x22, 0xea, 0x07, 0x89, 0x6a, 0xc9,
	0xea, 0x90, 0x8c, 0x5f, 0x70, 0xf8, 0x50, 0xa0, 0xc8, 0x82, 0x8a, 0x7e, 0xc1, 0x62, 0xa2, 0xe6,
	0xc4, 0xcd, 0x59, 0x99, 0x79, 0xb5, 0x7c, 0xaa, 0x3a, 0x65, 0xf2, 0xce, 0x40, 0xbb, 0xb0, 0xac,
	0x63, 0x06, 0xf4, 0x15, 0x1d, 0xa8, 0x21, 0x52, 0x9b, 0x09, 0xfa, 0x9c, 0xe3, 0x8e, 0x4e, 0x2d,
	0xac, 0xd9, 0x30, 0x6f, 0x40, 0xe2, 0x58, 0xdd, 0xd2, 0xd9, 0xb0, 0x43, 0x8e, 0x4f, 0xc3, 0x84,
	0x65, 0x7e, 0x93, 0x81, 0x25, 0xe5, 0x3e, 0xd3, 0xfe, 0x4d, 0x00, 0x9d, 0x92, 0x85, 0x8b, 0x3a,
	0xbf, 0xa4, 0x28, 0x4f, 0x42, 0x5e, 0xad, 0x18, 0x35, 0x2e, 0x4b, 0x87, 0x5d, 0x1a, 0xa9, 0x81,
	0x74, 0x26, 0xa2, 0x2c, 0x48, 0x4f, 0x04, 0x07, 0xed, 0x43, 0x35, 0xf0, 0x29, 0x4b, 0x82, 0xa3,
	0xc0, 0x23, 0x49, 0x10, 0xaa, 0xcb, 0x3a, 0x67, 0x8c, 0x9d, 0xe2, 0xa1, 0xc6, 0x89, 0x29, 0x3b,
	0x6f, 0xa4, 0x29, 0xbf, 0x9e, 0x7c, 0x85, 0xbf, 0x9a, 0x7c, 0x18, 0x96, 0x88, 0xef, 0x47, 0x34,
	0x8e, 0xe5, 0x07, 0xd4, 0xd1, 0xa6, 0xf9, 0x53, 0x09, 0x8a, 0x62, 0xb5, 0x78, 0x16, 0x26, 0x1f,
	0x7a, 0xbb, 0xc8, 0x9e, 0x7b, 0xbb, 0xc8, 0x7e, 0xb0, 0xed, 0xa2, 0x71, 0x72, 0xbb, 0x98, 0xf7,
	0xbb, 0xa8, 0x7d, 0xc3, 0x9e, 0xb7, 0x6f, 0xcc, 0xe1, 0x9f, 0xd8, 0x40, 0xf6, 0xe6, 0x6f, 0x20,
	0x73, 0xc2, 0xde, 0xdf, 0x4e, 0xc2, 0xdf, 0xd0, 0x20, 0x78, 0x45, 0x19, 0x6f, 0x9f, 0xea, 0x02,
	0x39, 0x53, 0x06, 0x6a, 0x41, 0x39, 0x88, 0x5d, 0x92, 0x24, 0xc4, 0xeb, 0x53, 0x1f, 0xaf, 0x2c,
	0x08, 0x80, 0x20, 0xbe, 0xa7, 0x38, 0xbc, 0xef, 0xc6, 0x36, 0xae, 0x09, 0xe9, 0x99, 0xb1, 0x2d,
	0xec, 0x36, 0x5e, 0x55, 0x76, 0x5b, 0xd8, 0xbb, 0x18, 0x29, 0x7b, 0x97, 0x8f, 0xcd, 0x71, 0xab,
	0x85, 0x2f, 0xca, 0xb1, 0x39, 0x6e, 0xb5, 0x24, 0x62, 0xe1, 0x7f, 0x69, 0xc4, 0x92, 0x88, 0x8d,
	0x2f, 0x69, 0xc4, 0x96, 0x48, 0x1b, 0x5f, 0xd6, 0x48, 0x5b, 0x22, 0xbb, 0xf8, 0xdf, 0x1a, 0x51,
	0x99, 0xef, 0x60, 0x2c, 0x8e, 0xe2, 0x8f, 0x12, 0xd9, 0xc3, 0xff, 0xd1, 0xc8, 0x9e, 0x44, 0xf6,
	0xf1, 0x9a, 0x46, 0xf6, 0x25, 0x72, 0x80, 0xff, 0xab, 0x91, 0x03, 0x81, 0x58, 0x3b, 0xf8, 0x8a,
	0x42, 0xac, 0x1d, 0x89, 0xb4, 0xf0, 0xff, 0xd4, 0x59, 0x96, 0xd4, 0x6c, 0x59, 0x78, 0x5d, 0x23,
	0x52, 0xb3, 0x65, 0xe3, 0x0d, 0x8d, 0x48, 0xcd, 0x56, 0x1b, 0xd7, 0x35, 0x22, 0x35, 0x5b, 0xbb,
	0xf8, 0xaa, 0x46, 0xa4, 0x66, 0xeb, 0x0e, 0x36, 0xf5, 0x59, 0x52, 0xb3, 0xb5, 0x87, 0x37, 0x35,
	0x22, 0x35, 0x5b, 0xfb, 0xf8, 0x9a, 0x46, 0xa4, 0x66, 0xeb, 0x00, 0x5f, 0xd7, 0x88, 0xd4, 0x6c,
	0xef, 0xe0, 0x1b, 0x0a, 0xb1, 0xa5, 0x66, 0xbb, 0x85, 0x6f, 0xaa, 0xb3, 0x6c, 0xa9, 0xd9, 0xb6,
	0x70, 0x43, 0x23, 0x52, 0xb3, 0x6d, 0xe3, 0xff, 0x6b, 0x44, 0x6a, 0xb6, 0xdb, 0x78, 0x4b, 0x23,
	0x52, 0xb3, 0xbd, 0x8b, 0x3f, 0xd2, 0x88, 0xd4, 0x6c, 0xdf, 0xc1, 0xb7, 0xf4, 0x59, 0x52, 0xb3,
	0xbd, 0x87, 0x6f, 0x6b, 0x44, 0x6a, 0xb6, 0xf7, 0x71, 0x53, 0x23, 0x52, 0xb3, 0x7d, 0x80, 0xb7,
	0x75, 0x1e, 0xa9, 0xb9, 0xbd, 0x83, 0x77, 0x14, 0xd2, 0xde, 0xd9, 0xba, 0x02, 0x05, 0xb9, 0xb6,
	0xa1, 0x25, 0xc8, 0x0e, 0x29, 0xab, 0x5d, 0x40, 0x25, 0xc8, 0x7f, 0x19, 0xf2, 0x47, 0x63, 0x6b,
	0x73, 0xba, 0x12, 0x89, 0xeb, 0x06, 0x50, 0x78, 0x4c, 0xa2, 0x5e, 0xc0, 0x59, 0x45, 0xc8, 0xf1,
	0x0f, 0x7d, 0xcd, 0xd8, 0xba, 0x0a, 0x95, 0xd9, 0x4f, 0x11, 0xf7, 0x3c, 0x26, 0x82, 0xb3, 0x04,
	0xd9, 0xe7, 0x69, 0xb7, 0x66, 0x6c, 0x6d, 0x4f, 0x29, 0xe2, 0x43, 0x83, 0x2a, 0x50, 0x94, 0x8b,
	0x2e, 0x19, 0xd4, 0x2e, 0xa0, 0x55, 0x58, 0xee, 0xb0, 0x38, 0x09, 0x92, 0x94, 0xcf, 0x72, 0x32,
	0xa8, 0x19, 0xf7, 0x6b, 0x3f, 0xbc, 0x59, 0x37, 0x7e, 0x7e, 0xb3, 0x6e, 0xfc, 0xf6, 0x66, 0xdd,
	0xf8, 0xfa, 0xf7, 0xf5, 0x0b, 0xdd, 0x82, 0xf8, 0xa3, 0x6a, 0xff, 0x19, 0x00, 0x00, 0xff, 0xff,
	0xd1, 0xc5, 0xf0, 0x87, 0xe7, 0x0e, 0x00, 0x00,
}

func (m *Person) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Person) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Person) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Gender != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Gender))
		i--
		dAtA[i] = 0x30
	}
	if m.BirthDay != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.BirthDay))
		i--
		dAtA[i] = 0x28
	}
	if m.Age != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Age))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Phone) > 0 {
		i -= len(m.Phone)
		copy(dAtA[i:], m.Phone)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Phone)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Order) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Order) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Order) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.EntrustQty) > 0 {
		i -= len(m.EntrustQty)
		copy(dAtA[i:], m.EntrustQty)
		i = encodeVarintPb(dAtA, i, uint64(len(m.EntrustQty)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.EntrustAmount) > 0 {
		i -= len(m.EntrustAmount)
		copy(dAtA[i:], m.EntrustAmount)
		i = encodeVarintPb(dAtA, i, uint64(len(m.EntrustAmount)))
		i--
		dAtA[i] = 0x62
	}
	if m.Side != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Side))
		i--
		dAtA[i] = 0x58
	}
	if m.EntrustStatus != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.EntrustStatus))
		i--
		dAtA[i] = 0x50
	}
	if m.EntrustType != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.EntrustType))
		i--
		dAtA[i] = 0x48
	}
	if len(m.Market) > 0 {
		i -= len(m.Market)
		copy(dAtA[i:], m.Market)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Market)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Currency) > 0 {
		i -= len(m.Currency)
		copy(dAtA[i:], m.Currency)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Currency)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.CounterId) > 0 {
		i -= len(m.CounterId)
		copy(dAtA[i:], m.CounterId)
		i = encodeVarintPb(dAtA, i, uint64(len(m.CounterId)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.OrgId) > 0 {
		i -= len(m.OrgId)
		copy(dAtA[i:], m.OrgId)
		i = encodeVarintPb(dAtA, i, uint64(len(m.OrgId)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.OrderId) > 0 {
		i -= len(m.OrderId)
		copy(dAtA[i:], m.OrderId)
		i = encodeVarintPb(dAtA, i, uint64(len(m.OrderId)))
		i--
		dAtA[i] = 0x22
	}
	if m.Aaid != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Aaid))
		i--
		dAtA[i] = 0x18
	}
	if len(m.AccountChannel) > 0 {
		i -= len(m.AccountChannel)
		copy(dAtA[i:], m.AccountChannel)
		i = encodeVarintPb(dAtA, i, uint64(len(m.AccountChannel)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *IllegalPerson_1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IllegalPerson_1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IllegalPerson_1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Gender != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Gender))
		i--
		dAtA[i] = 0x28
	}
	if m.BirthDay != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.BirthDay))
		i--
		dAtA[i] = 0x20
	}
	if m.Age != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Age))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Phone) > 0 {
		i -= len(m.Phone)
		copy(dAtA[i:], m.Phone)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Phone)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IllegalPerson_2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IllegalPerson_2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IllegalPerson_2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Gender != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Gender))
		i--
		dAtA[i] = 0x30
	}
	if m.BirthDay != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.BirthDay))
		i--
		dAtA[i] = 0x28
	}
	if m.Age != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Age))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Phone) > 0 {
		i -= len(m.Phone)
		copy(dAtA[i:], m.Phone)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Phone)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Detail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Detail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Detail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.UnitOnHandFrozen) > 0 {
		i -= len(m.UnitOnHandFrozen)
		copy(dAtA[i:], m.UnitOnHandFrozen)
		i = encodeVarintPb(dAtA, i, uint64(len(m.UnitOnHandFrozen)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.OutStandingFrozen) > 0 {
		i -= len(m.OutStandingFrozen)
		copy(dAtA[i:], m.OutStandingFrozen)
		i = encodeVarintPb(dAtA, i, uint64(len(m.OutStandingFrozen)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.UnitOnHand) > 0 {
		i -= len(m.UnitOnHand)
		copy(dAtA[i:], m.UnitOnHand)
		i = encodeVarintPb(dAtA, i, uint64(len(m.UnitOnHand)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.OutStanding) > 0 {
		i -= len(m.OutStanding)
		copy(dAtA[i:], m.OutStanding)
		i = encodeVarintPb(dAtA, i, uint64(len(m.OutStanding)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AccountInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccountInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AccountInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AccountProperties != nil {
		{
			size, err := m.AccountProperties.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.StockBooks) > 0 {
		for k := range m.StockBooks {
			v := m.StockBooks[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintPb(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPb(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPb(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.CashBooks) > 0 {
		for k := range m.CashBooks {
			v := m.CashBooks[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintPb(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPb(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPb(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Aaid != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Aaid))
		i--
		dAtA[i] = 0x18
	}
	if len(m.AccountChannel) > 0 {
		i -= len(m.AccountChannel)
		copy(dAtA[i:], m.AccountChannel)
		i = encodeVarintPb(dAtA, i, uint64(len(m.AccountChannel)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AccountProperties) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccountProperties) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AccountProperties) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AccountClass != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.AccountClass))
		i--
		dAtA[i] = 0x30
	}
	if m.AccountLevel != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.AccountLevel))
		i--
		dAtA[i] = 0x28
	}
	if m.AccountType != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.AccountType))
		i--
		dAtA[i] = 0x20
	}
	if len(m.MaxTradeCredit) > 0 {
		i -= len(m.MaxTradeCredit)
		copy(dAtA[i:], m.MaxTradeCredit)
		i = encodeVarintPb(dAtA, i, uint64(len(m.MaxTradeCredit)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.MainCurrency) > 0 {
		i -= len(m.MainCurrency)
		copy(dAtA[i:], m.MainCurrency)
		i = encodeVarintPb(dAtA, i, uint64(len(m.MainCurrency)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.MaxFinance) > 0 {
		i -= len(m.MaxFinance)
		copy(dAtA[i:], m.MaxFinance)
		i = encodeVarintPb(dAtA, i, uint64(len(m.MaxFinance)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Account) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Account) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Account) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Age != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Age))
		i--
		dAtA[i] = 0x30
	}
	if m.Gender != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Gender))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Identification) > 0 {
		i -= len(m.Identification)
		copy(dAtA[i:], m.Identification)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Identification)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.PhoneNumber) > 0 {
		i -= len(m.PhoneNumber)
		copy(dAtA[i:], m.PhoneNumber)
		i = encodeVarintPb(dAtA, i, uint64(len(m.PhoneNumber)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.AccountNo) > 0 {
		i -= len(m.AccountNo)
		copy(dAtA[i:], m.AccountNo)
		i = encodeVarintPb(dAtA, i, uint64(len(m.AccountNo)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *OrderPot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrderPot) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OrderPot) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.X40) > 0 {
		i -= len(m.X40)
		copy(dAtA[i:], m.X40)
		i = encodeVarintPb(dAtA, i, uint64(len(m.X40)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x82
	}
	if len(m.X39) > 0 {
		i -= len(m.X39)
		copy(dAtA[i:], m.X39)
		i = encodeVarintPb(dAtA, i, uint64(len(m.X39)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xfa
	}
	if m.X38 != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.X38))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xf0
	}
	if m.X37 != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.X37))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xe8
	}
	if m.X36 != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.X36))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xe0
	}
	if len(m.X35) > 0 {
		i -= len(m.X35)
		copy(dAtA[i:], m.X35)
		i = encodeVarintPb(dAtA, i, uint64(len(m.X35)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xda
	}
	if len(m.X34) > 0 {
		i -= len(m.X34)
		copy(dAtA[i:], m.X34)
		i = encodeVarintPb(dAtA, i, uint64(len(m.X34)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd2
	}
	if len(m.X33) > 0 {
		i -= len(m.X33)
		copy(dAtA[i:], m.X33)
		i = encodeVarintPb(dAtA, i, uint64(len(m.X33)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xca
	}
	if len(m.X32) > 0 {
		i -= len(m.X32)
		copy(dAtA[i:], m.X32)
		i = encodeVarintPb(dAtA, i, uint64(len(m.X32)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc2
	}
	if len(m.X31) > 0 {
		i -= len(m.X31)
		copy(dAtA[i:], m.X31)
		i = encodeVarintPb(dAtA, i, uint64(len(m.X31)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xba
	}
	if m.X30 != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.X30))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb0
	}
	if m.X29 != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.X29))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa8
	}
	if m.X28 != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.X28))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa0
	}
	if m.X27 != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.X27))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x98
	}
	if m.X26 != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.X26))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x90
	}
	if len(m.X25) > 0 {
		i -= len(m.X25)
		copy(dAtA[i:], m.X25)
		i = encodeVarintPb(dAtA, i, uint64(len(m.X25)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x8a
	}
	if len(m.X24) > 0 {
		i -= len(m.X24)
		copy(dAtA[i:], m.X24)
		i = encodeVarintPb(dAtA, i, uint64(len(m.X24)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x82
	}
	if len(m.X23) > 0 {
		i -= len(m.X23)
		copy(dAtA[i:], m.X23)
		i = encodeVarintPb(dAtA, i, uint64(len(m.X23)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xfa
	}
	if len(m.X22) > 0 {
		i -= len(m.X22)
		copy(dAtA[i:], m.X22)
		i = encodeVarintPb(dAtA, i, uint64(len(m.X22)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf2
	}
	if len(m.X21) > 0 {
		i -= len(m.X21)
		copy(dAtA[i:], m.X21)
		i = encodeVarintPb(dAtA, i, uint64(len(m.X21)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xea
	}
	if m.X20 != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.X20))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe0
	}
	if m.X19 != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.X19))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd8
	}
	if m.X18 != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.X18))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd0
	}
	if m.X17 != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.X17))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc8
	}
	if m.X16 != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.X16))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc0
	}
	if len(m.X15) > 0 {
		i -= len(m.X15)
		copy(dAtA[i:], m.X15)
		i = encodeVarintPb(dAtA, i, uint64(len(m.X15)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if len(m.X14) > 0 {
		i -= len(m.X14)
		copy(dAtA[i:], m.X14)
		i = encodeVarintPb(dAtA, i, uint64(len(m.X14)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if len(m.X13) > 0 {
		i -= len(m.X13)
		copy(dAtA[i:], m.X13)
		i = encodeVarintPb(dAtA, i, uint64(len(m.X13)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if len(m.X12) > 0 {
		i -= len(m.X12)
		copy(dAtA[i:], m.X12)
		i = encodeVarintPb(dAtA, i, uint64(len(m.X12)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if len(m.X11) > 0 {
		i -= len(m.X11)
		copy(dAtA[i:], m.X11)
		i = encodeVarintPb(dAtA, i, uint64(len(m.X11)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.X5 != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.X5))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.X4 != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.X4))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.X3 != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.X3))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.IsAttached != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.IsAttached))
		i--
		dAtA[i] = 0x78
	}
	if m.Liveness != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Liveness))
		i--
		dAtA[i] = 0x70
	}
	if len(m.EntrustQty) > 0 {
		i -= len(m.EntrustQty)
		copy(dAtA[i:], m.EntrustQty)
		i = encodeVarintPb(dAtA, i, uint64(len(m.EntrustQty)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.EntrustAmount) > 0 {
		i -= len(m.EntrustAmount)
		copy(dAtA[i:], m.EntrustAmount)
		i = encodeVarintPb(dAtA, i, uint64(len(m.EntrustAmount)))
		i--
		dAtA[i] = 0x62
	}
	if m.Side != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Side))
		i--
		dAtA[i] = 0x58
	}
	if m.EntrustStatus != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.EntrustStatus))
		i--
		dAtA[i] = 0x50
	}
	if m.EntrustType != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.EntrustType))
		i--
		dAtA[i] = 0x48
	}
	if len(m.Market) > 0 {
		i -= len(m.Market)
		copy(dAtA[i:], m.Market)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Market)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Currency) > 0 {
		i -= len(m.Currency)
		copy(dAtA[i:], m.Currency)
		i = encodeVarintPb(dAtA, i, uint64(len(m.Currency)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.CounterId) > 0 {
		i -= len(m.CounterId)
		copy(dAtA[i:], m.CounterId)
		i = encodeVarintPb(dAtA, i, uint64(len(m.CounterId)))
		i--
		dAtA[i] = 0x32
	}
	if m.OrgId != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.OrgId))
		i--
		dAtA[i] = 0x28
	}
	if m.OrderId != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.OrderId))
		i--
		dAtA[i] = 0x20
	}
	if m.Aaid != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Aaid))
		i--
		dAtA[i] = 0x18
	}
	if len(m.AccountChannel) > 0 {
		i -= len(m.AccountChannel)
		copy(dAtA[i:], m.AccountChannel)
		i = encodeVarintPb(dAtA, i, uint64(len(m.AccountChannel)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintPb(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintPb(dAtA []byte, offset int, v uint64) int {
	offset -= sovPb(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Person) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovPb(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.Phone)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.Age != 0 {
		n += 1 + sovPb(uint64(m.Age))
	}
	if m.BirthDay != 0 {
		n += 1 + sovPb(uint64(m.BirthDay))
	}
	if m.Gender != 0 {
		n += 1 + sovPb(uint64(m.Gender))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Order) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovPb(uint64(m.Id))
	}
	l = len(m.AccountChannel)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.Aaid != 0 {
		n += 1 + sovPb(uint64(m.Aaid))
	}
	l = len(m.OrderId)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.OrgId)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.CounterId)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.Currency)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.Market)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.EntrustType != 0 {
		n += 1 + sovPb(uint64(m.EntrustType))
	}
	if m.EntrustStatus != 0 {
		n += 1 + sovPb(uint64(m.EntrustStatus))
	}
	if m.Side != 0 {
		n += 1 + sovPb(uint64(m.Side))
	}
	l = len(m.EntrustAmount)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.EntrustQty)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IllegalPerson_1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.Phone)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.Age != 0 {
		n += 1 + sovPb(uint64(m.Age))
	}
	if m.BirthDay != 0 {
		n += 1 + sovPb(uint64(m.BirthDay))
	}
	if m.Gender != 0 {
		n += 1 + sovPb(uint64(m.Gender))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IllegalPerson_2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.Phone)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.Age != 0 {
		n += 1 + sovPb(uint64(m.Age))
	}
	if m.BirthDay != 0 {
		n += 1 + sovPb(uint64(m.BirthDay))
	}
	if m.Gender != 0 {
		n += 1 + sovPb(uint64(m.Gender))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Detail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OutStanding)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.UnitOnHand)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.OutStandingFrozen)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.UnitOnHandFrozen)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AccountInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovPb(uint64(m.Id))
	}
	l = len(m.AccountChannel)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.Aaid != 0 {
		n += 1 + sovPb(uint64(m.Aaid))
	}
	if len(m.CashBooks) > 0 {
		for k, v := range m.CashBooks {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovPb(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovPb(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovPb(uint64(mapEntrySize))
		}
	}
	if len(m.StockBooks) > 0 {
		for k, v := range m.StockBooks {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovPb(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovPb(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovPb(uint64(mapEntrySize))
		}
	}
	if m.AccountProperties != nil {
		l = m.AccountProperties.Size()
		n += 1 + l + sovPb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AccountProperties) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MaxFinance)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.MainCurrency)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.MaxTradeCredit)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.AccountType != 0 {
		n += 1 + sovPb(uint64(m.AccountType))
	}
	if m.AccountLevel != 0 {
		n += 1 + sovPb(uint64(m.AccountLevel))
	}
	if m.AccountClass != 0 {
		n += 1 + sovPb(uint64(m.AccountClass))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Account) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovPb(uint64(m.Id))
	}
	l = len(m.AccountNo)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.PhoneNumber)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.Identification)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.Gender != 0 {
		n += 1 + sovPb(uint64(m.Gender))
	}
	if m.Age != 0 {
		n += 1 + sovPb(uint64(m.Age))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OrderPot) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovPb(uint64(m.Id))
	}
	l = len(m.AccountChannel)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.Aaid != 0 {
		n += 1 + sovPb(uint64(m.Aaid))
	}
	if m.OrderId != 0 {
		n += 1 + sovPb(uint64(m.OrderId))
	}
	if m.OrgId != 0 {
		n += 1 + sovPb(uint64(m.OrgId))
	}
	l = len(m.CounterId)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.Currency)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.Market)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.EntrustType != 0 {
		n += 1 + sovPb(uint64(m.EntrustType))
	}
	if m.EntrustStatus != 0 {
		n += 1 + sovPb(uint64(m.EntrustStatus))
	}
	if m.Side != 0 {
		n += 1 + sovPb(uint64(m.Side))
	}
	l = len(m.EntrustAmount)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	l = len(m.EntrustQty)
	if l > 0 {
		n += 1 + l + sovPb(uint64(l))
	}
	if m.Liveness != 0 {
		n += 1 + sovPb(uint64(m.Liveness))
	}
	if m.IsAttached != 0 {
		n += 1 + sovPb(uint64(m.IsAttached))
	}
	if m.X3 != 0 {
		n += 2 + sovPb(uint64(m.X3))
	}
	if m.X4 != 0 {
		n += 2 + sovPb(uint64(m.X4))
	}
	if m.X5 != 0 {
		n += 2 + sovPb(uint64(m.X5))
	}
	l = len(m.X11)
	if l > 0 {
		n += 2 + l + sovPb(uint64(l))
	}
	l = len(m.X12)
	if l > 0 {
		n += 2 + l + sovPb(uint64(l))
	}
	l = len(m.X13)
	if l > 0 {
		n += 2 + l + sovPb(uint64(l))
	}
	l = len(m.X14)
	if l > 0 {
		n += 2 + l + sovPb(uint64(l))
	}
	l = len(m.X15)
	if l > 0 {
		n += 2 + l + sovPb(uint64(l))
	}
	if m.X16 != 0 {
		n += 2 + sovPb(uint64(m.X16))
	}
	if m.X17 != 0 {
		n += 2 + sovPb(uint64(m.X17))
	}
	if m.X18 != 0 {
		n += 2 + sovPb(uint64(m.X18))
	}
	if m.X19 != 0 {
		n += 2 + sovPb(uint64(m.X19))
	}
	if m.X20 != 0 {
		n += 2 + sovPb(uint64(m.X20))
	}
	l = len(m.X21)
	if l > 0 {
		n += 2 + l + sovPb(uint64(l))
	}
	l = len(m.X22)
	if l > 0 {
		n += 2 + l + sovPb(uint64(l))
	}
	l = len(m.X23)
	if l > 0 {
		n += 2 + l + sovPb(uint64(l))
	}
	l = len(m.X24)
	if l > 0 {
		n += 2 + l + sovPb(uint64(l))
	}
	l = len(m.X25)
	if l > 0 {
		n += 2 + l + sovPb(uint64(l))
	}
	if m.X26 != 0 {
		n += 2 + sovPb(uint64(m.X26))
	}
	if m.X27 != 0 {
		n += 2 + sovPb(uint64(m.X27))
	}
	if m.X28 != 0 {
		n += 2 + sovPb(uint64(m.X28))
	}
	if m.X29 != 0 {
		n += 2 + sovPb(uint64(m.X29))
	}
	if m.X30 != 0 {
		n += 2 + sovPb(uint64(m.X30))
	}
	l = len(m.X31)
	if l > 0 {
		n += 2 + l + sovPb(uint64(l))
	}
	l = len(m.X32)
	if l > 0 {
		n += 2 + l + sovPb(uint64(l))
	}
	l = len(m.X33)
	if l > 0 {
		n += 2 + l + sovPb(uint64(l))
	}
	l = len(m.X34)
	if l > 0 {
		n += 2 + l + sovPb(uint64(l))
	}
	l = len(m.X35)
	if l > 0 {
		n += 2 + l + sovPb(uint64(l))
	}
	if m.X36 != 0 {
		n += 2 + sovPb(uint64(m.X36))
	}
	if m.X37 != 0 {
		n += 2 + sovPb(uint64(m.X37))
	}
	if m.X38 != 0 {
		n += 2 + sovPb(uint64(m.X38))
	}
	l = len(m.X39)
	if l > 0 {
		n += 2 + l + sovPb(uint64(l))
	}
	l = len(m.X40)
	if l > 0 {
		n += 2 + l + sovPb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovPb(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozPb(x uint64) (n int) {
	return sovPb(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Person) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Person: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Person: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Age", wireType)
			}
			m.Age = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Age |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BirthDay", wireType)
			}
			m.BirthDay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BirthDay |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gender", wireType)
			}
			m.Gender = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Gender |= Gender(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Order) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Order: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Order: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountChannel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountChannel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aaid", wireType)
			}
			m.Aaid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Aaid |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrgId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrgId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CounterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CounterId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Currency", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Currency = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Market", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Market = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntrustType", wireType)
			}
			m.EntrustType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EntrustType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntrustStatus", wireType)
			}
			m.EntrustStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EntrustStatus |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Side", wireType)
			}
			m.Side = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Side |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntrustAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EntrustAmount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntrustQty", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EntrustQty = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IllegalPerson_1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IllegalPerson_1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IllegalPerson_1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Age", wireType)
			}
			m.Age = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Age |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BirthDay", wireType)
			}
			m.BirthDay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BirthDay |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gender", wireType)
			}
			m.Gender = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Gender |= Gender(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IllegalPerson_2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IllegalPerson_2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IllegalPerson_2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Age", wireType)
			}
			m.Age = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Age |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BirthDay", wireType)
			}
			m.BirthDay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BirthDay |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gender", wireType)
			}
			m.Gender = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Gender |= Gender(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Detail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Detail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Detail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutStanding", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutStanding = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnitOnHand", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UnitOnHand = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutStandingFrozen", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutStandingFrozen = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnitOnHandFrozen", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UnitOnHandFrozen = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccountInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccountInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccountInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountChannel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountChannel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aaid", wireType)
			}
			m.Aaid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Aaid |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CashBooks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CashBooks == nil {
				m.CashBooks = make(map[string]*Detail)
			}
			var mapkey string
			var mapvalue *Detail
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPb
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPb
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthPb
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthPb
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Detail{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPb(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthPb
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.CashBooks[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StockBooks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StockBooks == nil {
				m.StockBooks = make(map[string]*Detail)
			}
			var mapkey string
			var mapvalue *Detail
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPb
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPb
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthPb
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthPb
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Detail{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPb(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthPb
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.StockBooks[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountProperties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AccountProperties == nil {
				m.AccountProperties = &AccountProperties{}
			}
			if err := m.AccountProperties.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccountProperties) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccountProperties: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccountProperties: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxFinance", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MaxFinance = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MainCurrency", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MainCurrency = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTradeCredit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MaxTradeCredit = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountType", wireType)
			}
			m.AccountType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccountType |= AccountType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountLevel", wireType)
			}
			m.AccountLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccountLevel |= AccountLevel(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountClass", wireType)
			}
			m.AccountClass = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccountClass |= AccountClass(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Account) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Account: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Account: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountNo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountNo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhoneNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhoneNumber = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Identification", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Identification = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gender", wireType)
			}
			m.Gender = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Gender |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Age", wireType)
			}
			m.Age = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Age |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrderPot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrderPot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrderPot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountChannel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountChannel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aaid", wireType)
			}
			m.Aaid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Aaid |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderId", wireType)
			}
			m.OrderId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrderId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrgId", wireType)
			}
			m.OrgId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrgId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CounterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CounterId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Currency", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Currency = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Market", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Market = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntrustType", wireType)
			}
			m.EntrustType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EntrustType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntrustStatus", wireType)
			}
			m.EntrustStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EntrustStatus |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Side", wireType)
			}
			m.Side = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Side |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntrustAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EntrustAmount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntrustQty", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EntrustQty = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Liveness", wireType)
			}
			m.Liveness = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Liveness |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsAttached", wireType)
			}
			m.IsAttached = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsAttached |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field X3", wireType)
			}
			m.X3 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.X3 |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field X4", wireType)
			}
			m.X4 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.X4 |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field X5", wireType)
			}
			m.X5 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.X5 |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field X11", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.X11 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field X12", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.X12 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field X13", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.X13 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field X14", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.X14 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field X15", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.X15 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field X16", wireType)
			}
			m.X16 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.X16 |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field X17", wireType)
			}
			m.X17 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.X17 |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field X18", wireType)
			}
			m.X18 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.X18 |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field X19", wireType)
			}
			m.X19 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.X19 |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field X20", wireType)
			}
			m.X20 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.X20 |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field X21", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.X21 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field X22", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.X22 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field X23", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.X23 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field X24", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.X24 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 33:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field X25", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.X25 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field X26", wireType)
			}
			m.X26 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.X26 |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 35:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field X27", wireType)
			}
			m.X27 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.X27 |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 36:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field X28", wireType)
			}
			m.X28 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.X28 |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 37:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field X29", wireType)
			}
			m.X29 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.X29 |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 38:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field X30", wireType)
			}
			m.X30 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.X30 |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 39:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field X31", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.X31 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 40:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field X32", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.X32 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 41:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field X33", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.X33 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 42:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field X34", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.X34 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 43:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field X35", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.X35 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 44:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field X36", wireType)
			}
			m.X36 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.X36 |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 45:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field X37", wireType)
			}
			m.X37 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.X37 |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 46:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field X38", wireType)
			}
			m.X38 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.X38 |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 47:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field X39", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.X39 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 48:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field X40", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.X40 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPb(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPb
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPb
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupPb
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthPb
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthPb        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPb          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupPb = fmt.Errorf("proto: unexpected end of group")
)
